C – imperatywny, strukturalny język programowania wysokiego poziomu stworzony na początku lat siedemdziesiątych XX w. przez Dennisa Ritchiego do programowania systemów operacyjnych i innych zadań niskiego poziomu.
Poprzednikiem języka C był interpretowany język B, który Ritchie rozwinął w język C. Pierwszy okres rozwoju języka to lata 1969–1973. W roku 1973 w języku C udało się zaimplementować jądro systemu operacyjnego Unix. W 1978 roku Brian Kernighan i Dennis Ritchie opublikowali dokumentację języka pt. "C Programming Language" (wydanie polskie: "Język C").
C stał się popularny poza Laboratoriami Bella (gdzie powstał) po 1980 roku i stał się dominującym językiem do programowania systemów operacyjnych i aplikacji. Na bazie języka C w latach osiemdziesiątych Bjarne Stroustrup stworzył język C++, który ułatwia znacząco programowanie obiektowe.
W 1983 roku ANSI powołało komitet X3J11 w celu ustanowienia standardu języka C. Standard został zatwierdzony w 1989 roku jako ANSI X3.159-1989 "Programming Language C". Ta wersja języka jest określana nieformalnie jako ANSI C, standardowe C lub C89. W 1990 roku standard ANSI C został zaadoptowany przez ISO jako norma ISO/IEC 9899:1990. Ta wersja jest potocznie nazywana C90. Ponieważ normy wydane przez oba ciała standaryzacyjne są identyczne, wobec tego potoczne określenia C89 oraz C90 dotyczą tej samej wersji języka C. W 1999 roku ISO opublikowało normę ISO/IEC 9899:1999, język zgodny z tą normą jest nieformalnie nazywany C99. Ostatnia norma została opublikowana w 2011 roku pod nazwą ISO/IEC 9899:2011. Ta wersja języka jest potocznie nazywana C11 (C1X przed opublikowaniem normy).
Komentarz blokowy umieszcza się między sekwencją znaków "/*" a "*/", a komentarz liniowy rozpoczyna się sekwencją "//" oraz kończy znakiem końca linii. Komentarz liniowy wprowadzono do obecnego standardu języka C (ISO 9899:1999) z języka C++.
Lista słów kluczowych języka C na podstawie normy ISO/IEC 9899:2011 (C11).
Zmienne deklaruje się za pomocą konstrukcji:
Podane powyżej rozmiary zmiennych nie są standardem, mogą się różnić w zależności od środowiska (w systemach 64-bitowych zmienna long zajmuje zazwyczaj 64-bity).
Inną sprawą jest szerokość bajtu. Język C wymaga tylko, by bajt składał się z co najmniej 8 bitów. Jest to zwykle najmniejsza porcja danych, która może być adresowana.
Wielu programistów nie zdaje sobie sprawy z powyższych problemów, co może być przyczyną wielu błędów oprogramowania, a w rezultacie powstają różne luki w bezpieczeństwie oprogramowania.
Instrukcja codice_1 (ang. jeśli) to podstawowa instrukcja warunkowa w C – gdy warunek1 jest spełniony (zwraca wartość niezerową), wykonany zostanie kod zawarty w bloku ograniczonym klamrami. Fragment codice_3 jest opcjonalny. Problem wiszącego else jest rozwiązany przez przyporządkowanie "else" do na najbardziej zagnieżdżonego "if".
Pętla codice_4 (ang. podczas gdy) – wykonuje instrukcję tak długo, dopóki jej warunek jest spełniony (ma wartość różną od zera). Instrukcja sprawdza warunek przed wykonaniem ciała pętli. Pętla while może wykonywać się nieskończoną ilość razy, gdy wyrażenie nigdy nie przyjmie wartości 0, może także nie wykonać się nigdy, gdy wartość przed pierwszym przebiegiem będzie zerowa.
Przykład
Pętla będzie się wykonywać tak długo, jak zmienna codice_6 będzie dodatnia – wykona się więc 10 razy, drukując w każdym obiegu pętli kropkę na standardowe wyjście.
Pętla codice_7 (ang. wykonuj...dopóki) jest podobna do pętli codice_4 z tą różnicą, że warunek sprawdzany jest po każdym wykonaniu pętli, a więc instrukcje w pętli zawsze wykonają się co najmniej raz.
Przykład
Instrukcje w pętli wykonają się jeden raz i zostanie wydrukowana kropka na standardowe wyjście. Następnie sprawdzony będzie warunek pętli. W podanym przykładzie nie będzie spełniony – pętla zakończy więc działanie po jednym obiegu.
Pętla codice_10 (ang. dla) jest rozwinięciem pętli codice_4 o instrukcję wykonywaną przed pierwszym obiegiem oraz dodatkową instrukcję wykonywaną po każdym przebiegu – najczęściej służącą jako licznik obiegów. Często zmienną liczącą kolejne wykonania ciała pętli nazywa się iteratorem.
Przed pierwszym sprawdzeniem warunku pętli wykonane zostanie codice_13 (na diagramie oznaczone przez literkę A), następnie sprawdzony zostanie warunek umieszczony w codice_14 (literka B). Dopóki warunek będzie miał niezerową wartość, wykonywane będzie ciało pętli oraz – po każdym obiegu – codice_15. Jeśli codice_16 na początku jest fałszywe, ciało pętli nie wykona się wcale. Każde z wyrażeń można opuścić (nie opuszczając jednak towarzyszącego jej średnika) – zamiast nich domyślnie występować będzie wartość niezerowa. Ominięcie wszystkich wyrażeń lub tylko środkowego doprowadzi więc do powstania nieskończonej pętli.
Przykład
Powyższa pętla jest równoważna przykładowi podanemu przy pętli codice_4. Przed sprawdzeniem warunku zmienna codice_6 zainicjalizowana zostanie wartością 10. Następnie sprawdzony będzie warunek, który w tym przypadku zwróci wartość niezerową. Wykonane zostanie ciało pętli – na standardowe wyjście wydrukowana zostanie kropka. Następnie wykonana zostanie trzecia instrukcja – dekrementacja wartości codice_6. Pętla wykona się dziesięciokrotnie, a zmienna x, służąca w tej pętli za iterator, po jej zakończeniu będzie miała wartość 0.
Instrukcją decyzyjną codice_20 (ang. przełącznik) zastąpić można wielokrotne wywoływanie instrukcji warunkowej codice_1 np. dla różnych wartości tej samej zmiennej – przykładowo, gdy zmienna może przyjąć 10 różnych wartości, a dla każdej z nich należy podjąć inne działanie.
codice_23 najczęściej jest zmienną o określonej wartości. Jeśli tą wartością jest codice_24, wykonywane są instrukcje następujące po odpowiedniej etykiecie codice_25 aż do następnej instrukcji przerywającej, z reguły codice_26 (instrukcja opuszczenia nie musi występować na zakończenie każdego bloku rozpoczętego przez codice_25 – wykonany zostanie wtedy kod następnych przypadków). Przypadek codice_28 jest opcjonalny, określa instrukcje wykonywane, gdy wartość zmiennej nie jest równa żadnemu z wyszczególnionych przypadków.
Przykład
Powyższa instrukcja codice_20 wczyta liczbę ze standardowego wejścia i wyświetli "jeden", jeśli podana liczba to 0 lub 1, "dwa" jeśli podano 2 oraz "coś innego", jeśli podano jakąkolwiek inną wartość liczbową. W przypadku, gdyby program nie zawierał instrukcji codice_26, podanie wartości 0 lub 1 spowodowałoby wyświetlenie zarówno "jeden", jak i "dwa" oraz "coś innego".
Funkcje w C tworzy się za pomocą następującej składni:
Klasa pamięci, określenie zwracanego typu oraz lista parametrów są opcjonalne. Jeżeli nie podano typu, domyślnie jest to typ liczbowy codice_31, a instrukcję codice_32 kończącą funkcję i zwracającą wartość do funkcji nadrzędnej można pominąć. Listę argumentów tworzą wszystkie zmienne (zarówno przekazywane przez wartość jak i wskaźniki) wraz z określeniem ich typu. Dozwolona jest rekurencja, nie ma natomiast możliwości przeciążania funkcji (wprowadzonego m.in. w C++).
Przykład
Ta prosta funkcja zwraca podaną do niej liczbę podniesioną do kwadratu. Typ przekazanej do niej zmiennej oraz typ zwracany określony jest jako codice_31. Definicja funkcji umieszczona musi być w głównej przestrzeni (poza wszelkimi innymi funkcjami), a wywoływać ją można z każdego miejsca w programie. Przykładowo, aby zmiennej codice_34 przypisać wartość kwadratu z 16, wywołać należy: codice_35.
 Hello, world
W powyższym kodzie:
Język C pozwala na wykonywanie niskopoziomowych operacji, przez co wiele prostych błędów programistycznych nie jest wykrywanych przez kompilator, a przy wykonywaniu programu ujawniają się dopiero po jakimś czasie i w przypadkowych miejscach. Twórcy języka chcieli uniknąć sprawdzeń w czasie kompilacji i wykonywania programu, bo były one zbyt kosztowne czasowo, gdy C był implementowany po raz pierwszy. Z czasem powstały zewnętrzne narzędzia do wykonywania części z tych sprawdzeń. Nic nie przeszkadza implementacji języka w dostarczaniu takich sprawdzeń, ale też nie są one wymagane przez oficjalne standaryzacje.
Używanie języka C wymaga od programisty dokładnego zrozumienia pisanego kodu źródłowego, łącznie z mechanizmami kompilacyjnymi, dodatkowo komplikowanymi nieprzenośnością między platformami i kompilatorami, jak również rygorystycznego przestrzegania dobrych praktyk, szczególnie w odniesieniu do funkcji obsługujących wszelkiego rodzaju buforowania. Podobnie brak standaryzacji bibliotek wyższego poziomu jest powodem do uznania C za język niezalecany dla początkujących. Jednakże wiele z tych niedogodności można zniwelować tworząc własne elastyczniejsze rozwiązania. Pod względem zastosowań praktycznych C nie ustępuje innym językom, traci jednak w stosunku do nich, gdy wziąć pod uwagę czas i inne środki niezbędne do implementacji porównywalnych systemów.
C był tworzony jako mały i prosty język, co niewątpliwie przyczyniło się do jego popularności, ponieważ nowe kompilatory języka mogły być szybko tworzone na nowe platformy. Relatywnie niskopoziomowa natura języka daje programiście dokładną kontrolę nad tym, co robi komputer, jednocześnie pozwalając na specjalne dostosowanie i agresywne optymalizacje na konkretnych platformach. Pozwala to na szybkie działanie kodu nawet na ograniczonym sprzęcie, na przykład w systemach wbudowanych.
C nie zawiera wielu właściwości dostępnych w innych językach programowania:
Wiele z tych właściwości jest dostępnych w różnych kompilatorach jako dodatkowe rozszerzenia lub może zostać dostarczone przez zewnętrzne biblioteki albo zasymulowane przez odpowiednią dyscyplinę przy programowaniu. Na przykład, w większości języków zorientowanych obiektowo, funkcje-metody mają specjalny wskaźnik „this”, który wskazuje na aktualny obiekt. Przekazując ten wskaźnik jako zwykły argument funkcji podobna funkcjonalność może zostać uzyskana w C. Gdy w C++ napisano by:
w C można zapisać:
Możliwości graficzne można rozszerzyć poprzez:
Wiele operacji w C mających niezdefiniowane zachowanie nie jest sprawdzanych w czasie kompilacji. W przypadku C, „niezdefiniowane zachowanie” oznacza, że zachowanie nie jest opisane w standardzie i co dokładnie się stanie nie musi być opisane w dokumentacji danej implementacji C. W praktyce czasami poleganie na niezdefiniowanych zachowaniach może prowadzić do trudnych w rozpoznaniu błędów. Zachowania te mogą różnić się między kompilatorami C. Głównym celem pozostawienia niektórych zachowań jako niezdefiniowane jest pozwolenie kompilatorowi na generowanie bardziej wydajnego kodu dla zdefiniowanych zachowań, co jest ważne dla głównej roli języka C jako języka implementacji systemów; unikanie niezdefiniowanych zachowań jest odpowiedzialnością programisty. Przykłady niezdefiniowanych zachowań:
Wszystkie te operacje to błędy programistyczne, które mogą się zdarzyć w wielu językach programowania; C przyciąga krytykę ponieważ jego standard wyraźnie wylicza wiele przypadków niezdefiniowanego zachowania, także tam, gdzie mogłoby ono zostać dobrze zdefiniowane i nie zawiera żadnego mechanizmu obsługi błędów w czasie wykonywania programu.
Automatycznie i dynamicznie alokowane obiekty nie są koniecznie zainicjalizowane; początkowo mają niezdefiniowane wartości (zwykle zbiór bitów który akurat był poprzednio w danym miejscu w pamięci, który nawet może nie reprezentować żadnej prawidłowej wartości dla danego typu danych). Gdy program próbuje odczytać taką niezainicjalizowaną wartość, rezultat jest niezdefiniowany. Wiele współczesnych kompilatorów próbuje wykryć i ostrzec przed tym problemem, ale pojawiają się błędy pierwszego i drugiego rodzaju.
Innym częstym problemem jest konieczność ręcznej synchronizacji użycia pamięci na stercie. Na przykład, gdy jedyny wskaźnik na przydzieloną pamięć wyjdzie poza zasięg lub gdy jego wartość się zmieni przed wywołaniem na nim free (), to pamięć nie może zostać już odzyskana do dalszego użycia i jest stracona do końca działania programu. Zjawisko to nazywa się wyciekiem pamięci. Odwrotnie, możliwe jest zwolnienie pamięci zbyt wcześnie i mimo to dalsze odwoływanie się do niej; ponieważ system alokacji pamięci może ją w każdej chwili wykorzystać do innych celów, dochodzi do nieprzewidywalnych zachowań programu, gdy dane miejsce pamięci ma wielu użytkowników jednocześnie uszkadzających sobie nawzajem dane. Zwykle symptomy te pojawiają się w miejscach programu zupełnie oddalonych od faktycznego błędu. Błędy te można ograniczyć przez użycie dodatkowego odśmiecacza lub RAII.
Wskaźniki są głównym źródłem zagrożeń w języku C. Ponieważ mogą zwykle wskazywać na dowolny obszar pamięci, prowadzić to może do niepożądanych efektów. Nawet odpowiednio używane wskaźniki wskazujące na bezpieczne miejsca, mogą zostać przypadkiem przeniesione na miejsca niebezpieczne przez użycie nieodpowiedniej arytmetyki wskaźników; pamięć na którą wskazują może być zwolniona i użyta już na coś innego (zwisający wskaźnik); mogą być niezainicjalizowane (dziki wskaźnik), lub mogą mieć bezpośrednio przypisaną wartość poprzez rzutowanie, unię, lub inny uszkodzony wskaźnik. Ogólnie C pozwala na swobodną manipulację i konwersję typów wskaźników, chociaż kompilatory zwykle dostarczają opcje różnego poziomu ich kontroli. Inne języki niwelują problemy ze wskaźnikami poprzez użycie bardziej ograniczonych typów referencji.
Chociaż C wspiera tablice statyczne, nie jest wymagane, aby sprawdzany był zasięg ich indeksów. Na przykład, można zapisać w szóstym elemencie tablicy pięcioelementowej, powodując nadpisanie innej pamięci. Ten rodzaj błędu, przepełnienie bufora, jest źródłem wielu problemów z bezpieczeństwem komputerowym. Z drugiej strony, ponieważ technologia eliminacji sprawdzania zasięgu tablic praktycznie nie istniała w czasie tworzenia języka C, sprawdzanie zasięgu miało duży narzut czasu działania programu, zwłaszcza w obliczeniach numerycznych. Kilka lat później, niektóre kompilatory Fortranu miały przełącznik do włączania lub wyłączania sprawdzania zasięgu tablic. Byłoby to jednak dużo mniej użyteczne w języku C, gdzie argumenty o typie tablicowym są przekazywane przez zwykłe wskaźniki.
Tablice wielowymiarowe są często używane w algorytmach numerycznych (zwłaszcza z algebry liniowej) do zapisu macierzy. Struktura tablicy w języku C jest bardzo dobrze przystosowana do tego zadania. Ponieważ zmienne są przekazywane jedynie jako proste wskaźniki, zasięg tablicy musi być znany i stały lub osobno przekazywany do funkcji korzystających z nich i dostęp do tablic dynamicznych nie może być realizowany za pomocą podwójnego indeksu (obejściem jest użycie dodatkowej tablicy „rzędu” wskaźników do kolumn). Problemy te są omówione w książce "Numerical Recipes in C", rozdział 1.2, strona 22ff.
C99 wprowadził tablice o zmiennym rozmiarze, które rozwiązują niektóre problemy ze zwykłymi tablicami z C.
Chociaż naśladowana przez wiele języków z powodu jej popularności, składnia C jest często uznawana za jeden z jego słabszych punktów. Na przykład, Kernighan i Ritchie mówią w drugiej edycji "The C Programming Language": „C, tak jak każdy inny język, ma swoje słabe punkty. Niektóre operatory mają zły priorytet; niektóre części składni mogłyby być lepsze.”
Niektóre konkretne problemy to:
Jedną z krytykowanych cech języka C jest możliwość tworzenia zwięzłych ponad miarę fragmentów kodu. Klasyczny przykład pojawiający się w K&R to poniższa funkcja kopiująca zawartość ciągu znaków wskazywanego przez codice_41 do ciągu znaków wskazywanego przez codice_42:
W tym przykładzie, s i t to wskaźniki na pierwsze elementy tablic znaków zakończonych wartościami null. Każde przejście pętli wyrażenia while wykonuje poniższe operacje:
Powyższy kod może zostać zapisany jako:
Przy użyciu współczesnego optymalizującego kompilatora powyższe dwie funkcje skompilują się do identycznej sekwencji instrukcji procesora, więc mniejszy kod programu niekoniecznie oznacza mniejszy kod wynikowy. W bardziej rozwlekłych językach programowania takich jak Pascal, podobna iteracja wymagałaby wielu poleceń. Dla programistów C, ekonomia stylu jest idiomatyczna i pozwala na krótsze wyrażenia; dla krytyków możliwość zrobienia zbyt wiele w jednej linii kodu C prowadzi do problemów z czytelnością kodu.
Osobliwością języka C jest sposób traktowania tablic, a w szczególności ich indeksowania. W zasięgu deklaracji:
dostęp do np. drugiego elementu tablicy codice_41 uzyskuje się poprzez zapis:
Jednakże (w odróżnieniu od większości innych języków programowania) symbol „codice_45” nie jest tylko elementem składni (jak np. w Pascalu), ale również operatorem, który przez kompilator traktowany jest następująco:
Ponieważ dodawanie jest przemienne, przemienny jest również operator „codice_45”, a to oznacza, że poniższy fragment kodu (mimo dość zaskakującego zapisu) jest poprawny i równoważny przytoczonemu powyżej:
Cechy tej nie mają nawet te języki, których składnia wywodzi się z C, jak np. Java, JavaScript czy Perl.
Inną ciekawostką jest istnienie w C tzw. operatora połączenia, zapisywanego jako „codice_47” (przecinek). Operator ten powoduje obliczenie najpierw wartości lewego argumentu, potem prawego, a wartością i typem całego wyrażenia jest wartość i typ prawego argumentu. Może to powodować nieoczekiwane skutki, jeśli program kodowany jest przez początkującego i mało uważnego programistę. Poniższy fragment kodu (który mógłby powstać jako skutek pomylenia kropki dziesiętnej z przecinkiem) zostanie przez kompilator potraktowany jako poprawny, a wartością zmiennej codice_6 stanie się codice_49:
Zastanawiający jest również fakt wybrania dwuznaku codice_50 jako otwarcia komentarza (było to najprawdopodobniej zapożyczenie z języka PL/I), można sobie bowiem wyobrazić fragment poprawnego kodu, który w sposób absolutnie niezgodny z intencją programisty niespodziewanie otwiera komentarz. Oto przykład:
Intencją programisty było tu podzielenie zmiennej codice_51 przez wartość wyłuskaną spod wskaźnika codice_52, jednak kompilator znajdzie w kodzie nie dzielenie („codice_53”) i wyłuskanie („codice_54”), a otwarcie komentarza („codice_50”).
Problem rozwiązuje wstawienie do wyrażenia jednej spacji:

